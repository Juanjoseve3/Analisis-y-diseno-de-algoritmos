# -*- coding: utf-8 -*-
"""Algoritmos_de_Ordenamiento.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GwnX5ICh751wtj6bHcUEB1Wnm1hXCXJ0

# **Algoritmos de Ordenamiento**

##**API**
"""

import pandas as pd
from pandas import json_normalize
import requests
import json

link = "https://www.datos.gov.co/resource/fut2-keu8.json"
data = requests.get(link)
datos = json.loads(data.text)
datos = json_normalize(datos)
datos

datos_api = datos['no_accesos_fijos_a_internet']
datos_api = datos_api.astype(int)
print(list(datos_api))

"""# **Clase Algoritmos de Ordenamiento**"""

class algoritmos_de_ordenamiento:

  def Bubble_Sort(self, lista):         
    tamaño = len(lista) - 1
    for i in range(1, tamaño):
      for j in range(0, tamaño):
        if lista[j] > lista[j+1]:
          temp = lista[j]
          lista[j] = lista[j+1]
          lista[j+1] = temp

    return lista

  def heapify(self, lista, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
 
    if left < n and lista[left] > lista[largest]:
      largest = left
 
    if right < n and lista[right] > lista[largest]:
      largest = right
 
    if largest != i:
      lista[i], lista[largest] = lista[largest], lista[i]
      self.heapify(lista, n, largest)
 
  def Heap_Sort(self, lista):
    n = len(lista)

    for i in range(n // 2 - 1, -1, -1):
      self.heapify(lista, n, i)

    for i in range(n-1, 0, -1):
      lista[i], lista[0] = lista[0], lista[i]
      self.heapify(lista, i, 0)

    return lista

  def Merge(self, lista_left, lista_right):
    lista_resultado = []
    while(len(lista_left) > 0 and len(lista_right) > 0):
      if lista_left[0] < lista_right[0]:
        lista_resultado.append(lista_left[0])
        lista_left = lista_left[1:]
      else:
        lista_resultado.append(lista_right[0])
        lista_right = lista_right[1:]

    if len(lista_left) > 0:
      lista_resultado = lista_resultado + lista_left
    if len(lista_right) > 0:
      lista_resultado = lista_resultado + lista_right

    return lista_resultado


  def Merge_Sort(self, lista):
    if len(lista) <= 1:
      return lista

    lista_izquierda = lista[:len(lista)//2]
    lista_derecha = lista[len(lista)//2:]

    lista_izquierda = self.Merge_Sort(lista_izquierda)
    lista_derecha = self.Merge_Sort(lista_derecha)

    return self.Merge(lista_izquierda, lista_derecha)

  def count_digits(self, number):
    if(number<10 and number>0):
      return 1
    else:
      if number < 0:
        positiveNumber = number * (-1)
      else:
        positiveNumber = number
      return 1 + self.count_digits(positiveNumber//10)

  def n_Number(self, lista):
    copia_lista = lista.copy()
    if lista != []:
      for i in range(len(copia_lista)-1):
        if self.count_digits(copia_lista[0]) < self.count_digits(copia_lista[1]):
          n = copia_lista[1]
          copia_lista.pop(0)
        else:
          n = copia_lista[0]
          copia_lista.pop(1)
      return self.count_digits(n)
    else:
      return 0

  def zero_completion(self, lista):
    n = self.n_Number(lista)
    new_list = []
    for i in lista:
      if self.count_digits(i) < n:
        fullNumber = f'{i:0{n}d}'
        new_list.append(fullNumber)
      else:
        fullNumberStr = str(i)
        new_list.append(fullNumberStr)
    return new_list

  def radix_Sort(self, lista):
    vector = []
    for i in range(10):
      vector.append([])
    contador = -1
    for i in range(len(lista[0])):
      for i in lista:
        if i[contador] == "0":
          vector[0].append(i)
        if i[contador] == "1":
          vector[1].append(i)
        if i[contador] == "2":
          vector[2].append(i)
        if i[contador] == "3":
          vector[3].append(i)
        if i[contador] == "4":
          vector[4].append(i)
        if i[contador] == "5":
          vector[5].append(i)
        if i[contador] == "6":
          vector[6].append(i)
        if i[contador] == "7":
          vector[7].append(i)
        if i[contador] == "8":
          vector[8].append(i)
        if i[contador] == "9":
          vector[9].append(i)
      contador -= 1
      acumulador = []
      for i in vector:
        if i != []:
          acumulador = acumulador + i
      lista = acumulador
      vector = [[],[],[],[],[],[],[],[],[],[]]

    final_list = []
    for i in acumulador:
      final_list.append(int(i))

    return final_list

  def Quick_Sort(self, lista):
    if len(lista) <= 1:
      return lista
    else:
      pivote = lista.pop()
      lista1 = []
      lista2 = []

    for i in lista:
      if i <= pivote:
        lista1.append(i)
      else:
        lista2.append(i)

    lista1 = self.Quick_Sort(lista1)
    lista2 = self.Quick_Sort(lista2)

    return lista1 + [pivote] + lista2

  def Counting_Sort(self, lista):
    min_val = min(lista)
    max_val = max(lista)

    count = [0] * (max_val - min_val + 1)

    for num in lista:
        count[num - min_val] += 1

    for i in range(1, max_val - min_val + 1):
        count[i] += count[i - 1]

    output = [0] * len(lista)

    for num in lista:
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1

    return output

ordenamiento = algoritmos_de_ordenamiento()
print(ordenamiento.Bubble_Sort(list(datos_api)))

ordenamiento = algoritmos_de_ordenamiento()
print(ordenamiento.Heap_Sort(list(datos_api)))

ordenamiento = algoritmos_de_ordenamiento()
print(ordenamiento.Merge_Sort(list(datos_api)))

ordenamiento = algoritmos_de_ordenamiento()
print(ordenamiento.radix_Sort(ordenamiento.zero_completion(list(datos_api))))

ordenamiento = algoritmos_de_ordenamiento()
print(ordenamiento.Quick_Sort(list(datos_api)))

ordenamiento = algoritmos_de_ordenamiento()
print(ordenamiento.Counting_Sort(list(datos_api)))

"""# **Evidencias**

## **Buble Sort**
"""

def Bubble_Sort(lista):         
  tamaño = len(lista) - 1
  for i in range(1, tamaño):
    for j in range(0, tamaño):
      if lista[j] > lista[j+1]:
        temp = lista[j]
        lista[j] = lista[j+1]
        lista[j+1] = temp

  return lista

Bubble_Sort(datos)

"""## **Heap Sort**"""

def heapify(lista, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
 
    if left < n and lista[left] > lista[largest]:
        largest = left
 
    if right < n and lista[right] > lista[largest]:
        largest = right
 
    if largest != i:
        lista[i], lista[largest] = lista[largest], lista[i]
        heapify(lista, n, largest)
 
def Heap_Sort(lista):
    n = len(lista)

    for i in range(n // 2 - 1, -1, -1):
        heapify(lista, n, i)

    for i in range(n-1, 0, -1):
        lista[i], lista[0] = lista[0], lista[i]
        heapify(lista, i, 0)

    return lista


Heap_Sort(datos)

"""##**Merge Sort**"""

def Merge(lista_left, lista_right):
  lista_resultado = []
  while(len(lista_left) > 0 and len(lista_right) > 0):
    if lista_left[0] < lista_right[0]:
      lista_resultado.append(lista_left[0])
      lista_left = lista_left[1:]
    else:
      lista_resultado.append(lista_right[0])
      lista_right = lista_right[1:]

  if len(lista_left) > 0:
    lista_resultado = lista_resultado + lista_left
  if len(lista_right) > 0:
    lista_resultado = lista_resultado + lista_right

  return lista_resultado


def Merge_Sort(lista):
  if len(lista) <= 1:
    return lista

  lista_izquierda = lista[:len(lista)//2]
  lista_derecha = lista[len(lista)//2:]

  lista_izquierda = Merge_Sort(lista_izquierda)
  lista_derecha = Merge_Sort(lista_derecha)

  return Merge(lista_izquierda, lista_derecha)

Merge_Sort(datos)

"""## **Radix Sort**"""

def count_digits(number):
  if(number<10 and number>0):
    return 1
  else:
    if number < 0:
      positiveNumber = number * (-1)
    else:
      positiveNumber = number
    return 1 + count_digits(positiveNumber//10)

def n_Number(lista):
  copia_lista = lista.copy()
  if lista != []:
    for i in range(len(copia_lista)-1):
      if count_digits(copia_lista[0]) < count_digits(copia_lista[1]):
        n = copia_lista[1]
        copia_lista.pop(0)
      else:
        n = copia_lista[0]
        copia_lista.pop(1)
    return count_digits(n)
  else:
    return 0

def zero_completion(lista):
  n = n_Number(lista)
  new_list = []
  for i in lista:
    if count_digits(i) < n:
      fullNumber = f'{i:0{n}d}'
      new_list.append(fullNumber)
    else:
      fullNumberStr = str(i)
      new_list.append(fullNumberStr)
  return new_list

def radix_Sort(lista):
  vector = []
  for i in range(10):
    vector.append([])
  contador = -1
  for i in range(len(lista[0])):
    for i in lista:
      if i[contador] == "0":
        vector[0].append(i)
      if i[contador] == "1":
        vector[1].append(i)
      if i[contador] == "2":
        vector[2].append(i)
      if i[contador] == "3":
        vector[3].append(i)
      if i[contador] == "4":
        vector[4].append(i)
      if i[contador] == "5":
        vector[5].append(i)
      if i[contador] == "6":
        vector[6].append(i)
      if i[contador] == "7":
        vector[7].append(i)
      if i[contador] == "8":
        vector[8].append(i)
      if i[contador] == "9":
        vector[9].append(i)
    contador -= 1
    acumulador = []
    for i in vector:
      if i != []:
        acumulador = acumulador + i
    lista = acumulador
    vector = [[],[],[],[],[],[],[],[],[],[]]

  final_list = []
  for i in acumulador:
    final_list.append(int(i))

  return final_list

print(zero_completion(datos))
print("-------------------")
radix_Sort(zero_completion(datos))

"""## **Quick**"""

def Quick_Sort(lista):
  if len(lista) <= 1:
    return lista
  else:
    pivote = lista.pop()
    lista1 = []
    lista2 = []

  for i in lista:
    if pivote <= pivote:
      lista1.append(i)
    else:
      lista2.append(i)

  lista1 = Quick_Sort(lista1)
  lista2 = Quick_Sort(lista2)

  return lista1 + [pivote] + lista2
  
Quick_Sort(datos)

"""## **Counting Sort**"""

def Counting_Sort(lista):
    min_val = min(lista)
    max_val = max(lista)

    count = [0] * (max_val - min_val + 1)

    for num in lista:
        count[num - min_val] += 1

    for i in range(1, max_val - min_val + 1):
        count[i] += count[i - 1]

    output = [0] * len(lista)

    for num in lista:
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1

    return output

Counting_Sort(datos)

"""## **Pruebas y Análisis**

"""

def counting_sort(array1):
  max_val = max(array1)
  m = max_val + 1
  count = [0]*m 

  for a in array1:
    count[a] += 1

  i = 0
  for h in range(m):
    for c in range(count[h]):
      array1[i] = h
      i += 1
      
  return array1

def counting_sort2(array1):
  max_val = max(array1)
  m = max_val + 1
  lista_cuentas = [0]*m
  output = []

  # para almacenar las cuentas
  for a in array1:
    lista_cuentas[a] += 1

  #cuentas acumulados el primer elemento de lista cuentas
  for i in range( len(lista_cuentas)-1 ):
    lista_cuentas[i+1] += lista_cuentas[i]
  
  while True:
    array1[
        array1[ lista_cuentas[ array1[i] ] - 1 ]
    ] = array1[i]
      
  return array1

#https://www.programiz.com/dsa/counting-sort